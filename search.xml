<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023总结</title>
    <url>/2023/12/31/2023%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这几天给自己做个年终总结的想法越来越强烈，可惜荒废了多年的文笔，加上多年理工科文化的熏陶和自己有意避及写点东西的心情（我始终认为写作是需要特定环境下的特定心情的），却不知从何写起。江郎才尽的我早已忘记各类名人名言，或许10年前的我写这篇总结是会以诗、词结尾，但现在面对屏幕的我只能汗颜。同时觉得各大app的年终报告流水账似的总是从1月到12月记录让人看了厌烦。</p>
<p>虽说是年底，但我身上的任务却一点也没减少（苦笑），也许是处于仪式感，我索性把事情扔下，找个时间总结下23年的各种事务。</p>
<p>“生活不可能像你想象的那么好，也不会像你想象的那么糟”，2023年对我而言如果用一个词来形容，我觉得是<strong>充实</strong>。直白一点，就是累。</p>
<h2 id="1-学术">1. 学术</h2>
<blockquote>
<p>科研中95%的时间是令人沮丧的。</p>
</blockquote>
<p>与研一上的兴奋、轻松不同，23年上半年的西安本部学习生涯一直给我紧张、矛盾的氛围。线下答辩似的组会与对未来的迷茫贯穿了我上半年的生活。依稀记得当时每天最快乐的是11点从图书馆里出来到校门口买小吃。小吃摊主和城管斗智斗勇，见到巡逻车立马流利地收摊，留下我们一群人站在路口风中凌乱。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/7544FEE026E7A6045EE438E339316A59.png" alt="7544FEE026E7A6045EE438E339316A59" style="zoom:33%;" />
<p>于我而言，那段时间的科研生活是枯燥、乏味的，早已记不清多少次实验失败，心态爆炸，期间甚至一度怀疑自己能不能毕业。考研时从图书馆出来觉得学习一天非常充实，而读研后晚上背着电脑回寝室的路上多了些空虚与不知所措。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_6099.JPG" alt="IMG_6099" style="zoom: 20%;" />
<p>“千呼万唤始出来”，我在下半年开始前完成了第一篇小论文。赶稿的日子就不叙述了，依旧**。只是在提交后如释重负，感慨了小导与自己的差距：</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/28AFDDEC7A2F7652953A763538DAE65C.png" alt="28AFDDEC7A2F7652953A763538DAE65C" style="zoom:33%;" />
<p>当然，本部的生活也并不全是焦虑、迷茫，科研之外的生活也同样值得回味。和室友及小姐姐们一起打篮球、吃各种对我来说稀奇古怪的餐厅、和本科兄弟室内乱逛，令我印象最深刻的是傍晚骑着车打卡西北大学、陕西师范大学、西北政法大学，互相吐槽遇到的奇葩事。</p>
<p>那是一段很充实的日子，唯一的遗憾可能就是没有记录下我学生时代最后一节课。恍惚记得那是一个平常的上午，我只想赶紧回到食堂吃午饭，丝毫没有意识到我的学生生涯在某种程度上结束了。</p>
<p>下半年的杭州科研生活则明显轻松了许多，让我有更多的时间去放空自己，去准备工作方面的专业书籍以及追寻自己喜欢的事，并好好地热爱生活。我和同门经常开玩笑，“还是杭州组会形式爽”。</p>
<p>23年的学术科研分为两个明显割裂的阶段，上半年痛并快乐着与下半年略显宽松自由。我想，上半年可以看作大多数人的高三生活，那是一份宝贵的回忆，但不愿意再经历一次。我更喜欢下半年，可以有更多的机会斡旋学术科研与生活，有空余的时间做自己的想做的事，虽然我的哥们和两个室友都因为各种原因与我暂时分别了。</p>
<p>站在今天这个节点，我仍十分感激西电这个平台带给我更广阔的视野以及我导耐心地领着我一步步探索学术道路。还记得第一次协助审稿的惊讶，第一次坐飞机参与学术会议的兴奋，第一次在网站上投稿的新奇。这些独特经历足以让我可以有底气的说，“即使我没有做的很好，但我也知道学术是怎样一回事儿了”。如果非要找一个意义，那么这句话就是西安科研生活的意义。当我踏上回杭的火车时，对博士师兄们深厚的科研功底依旧敬佩。</p>
<p>“考研容易读研难”。</p>
<h2 id="2-编程技术">2. 编程技术</h2>
<p>半年的本部生活让我明白自己并不适合读博，那段时间的矛盾痛苦在于我确认自己不适合继续深造后，繁重的科研压力与找工作的冲突使我显得十分拧巴。在通过各种途径收集就业信息、形式后，我开始了就业方面的准备。难以两全，半年的时间我仅看完了编程语言入门圣经的一半多一些，力扣只做了不到10道题。</p>
<p>我的23年编程方面的东西基本都是下半年完成的：搭建<a href="https://www.xuluo.online/">个人网站</a>、看完3本专业书籍及视频、力扣完成40题等等。编程项目也开始了，不过23年最后一个月的规划出了些问题，断断续续的看了不到3个视频。老实说，这个进度可能要找实习来不及了（再次苦笑）：</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/B9CA8EC9BEA6BF54BC12AFAC9F9E7499.png" alt="B9CA8EC9BEA6BF54BC12AFAC9F9E7499" style="zoom:33%;" />
<p>后半年时间完成这些着实令人汗颜。实验室开放杂乱的环境可能让我始终无法静下心来去做一些事情，在这一年的最后两个月，我搬到了图书馆旁边的小自习室，我把它称之为“阁楼”，它有冰箱、微波炉和中央空调，虽然我一次都没用过哈哈。我喜欢中隐隐于市的感觉，它比较偏僻，但也有几位常客。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/94C454AA422D3EF07E455132523CE7BB.png" alt="94C454AA422D3EF07E455132523CE7BB" style="zoom: 15%;" />
<h2 id="3-个人生活">3. 个人生活</h2>
<blockquote>
<p>相遇是人世间的常态，离散也是。</p>
</blockquote>
<p>人总是在不断地得到与失去，尽管我知道悲欢离合是常态，但我依旧很讨厌旧人的离去。是三年舍友生活只能一年结束，好不容易摸清每个人秉性，四个人却再也没办法在夜里一块侃山；是两年和师姐的同门生涯相处地却不到一年；也是因轨迹不同和本科同学无可避免地渐行渐远。</p>
<p>所幸，今年也见了不少旧友，在西安和本科好哥们一起去大唐不夜城、爬华山、滑雪，在杭州和小班同学登宝石山、打卡钱塘江。还有和本科组员的匆匆碰面。“人面不知何处去，桃花依旧笑春风”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_6280.JPG" alt="IMG_6280" style="zoom:7%;" /><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_5981.JPG" alt="IMG_5981" style="zoom:7%;" /><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_8133.JPG" alt="IMG_8133" style="zoom:7%;" /><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_8237.JPG" alt="IMG_8237" style="zoom:7%;" /></p>
<p>这一年去的城市还有无锡和香港。无锡给我的印象是典型的南方城市，园林式的建筑和高绿植化的街道似一婉转优雅的女生，静静地坐在那里。香港则更加包容，处处带有人文关怀，带有电铃的红绿灯和随处可见的残疾人通道真的体现了**“以人为本”**的理念。就是吃的略微不惯和走在中环高楼大厦处稍显压抑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_7126.JPG" alt="IMG_7126" style="zoom:7%;" /><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_7667.JPG" alt="IMG_7667" style="zoom:7%;" /><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_7314.JPG" alt="IMG_7314" style="zoom:7%;" /><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_7546.JPG" alt="IMG_7546" style="zoom:7%;" /></p>
<p>除此之外，23年读完了4本课外书，写下了一段书评。读书，可以使我暂且逃离繁杂的科研现实世界，沉浸在另一片天地。“莫向外求”：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/CF992C7EBC6A63388AB619EDA2BEB1FC.png" alt="CF992C7EBC6A63388AB619EDA2BEB1FC" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/703045B4B07286BBECED0DC1C15C16CF.png" alt="703045B4B07286BBECED0DC1C15C16CF" style="zoom: 30%;" /></p>
<p>还有一些零零散散的生活记录，比如杭州亚运会灯光秀、云栖大会…</p>
<p><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_7042.JPG" alt="IMG_7042" style="zoom: 13%;" /><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/IMG_7984.JPG" alt="IMG_7984" style="zoom: 67%;" /></p>
<p>明天就是2024年了，我相信时间具有连续性，23年的最后一秒与24年的第一秒并没有什么不同。人生不如意事，十之八九。但这些并不妨碍人们对新的一年的殷切期望，我仍然很感激这一年经历的一切，尽管我依然迷茫，尽管生活依旧不那么阳光。</p>
<p>人生不如意事，十之八九。但这并不妨碍人们对未来的殷切渴望。尽管我依然迷茫，尽管生活依旧不那么阳光。</p>
<p>2023年12月27日，我在b站许下了2024年新年愿望：</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/7d4441752c1f1778210966e97fca3d0.jpg" alt="7d4441752c1f1778210966e97fca3d0" style="zoom: 33%;" />
<p>(虽然字挺丑…)</p>
<p>当然，还有一些期望我没有放到上面，我觉得那不是靠许愿实现的。</p>
<p>但愿人长久，千里共婵娟。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/0f2bb21dc39968ed0192b4fa0cb0c81.jpg" alt="0f2bb21dc39968ed0192b4fa0cb0c81" style="zoom: 15%;" />
<p>哦对，我们学校这里也贴上了“新桃”：</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/943769c20d7201f52c075a71f845d4f.jpg" alt="943769c20d7201f52c075a71f845d4f" style="zoom:25%;" />
<p>跨年就不在朋友圈更新啦，祝所有看到这篇文章的朋友们新年快乐！</p>
]]></content>
      <tags>
        <tag>新年伊始</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++后端开发岗位技能</title>
    <url>/2023/11/30/C-C-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B2%97%E4%BD%8D%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<p>经过搜集网上相关C++后端开发资料，整理了开发工程师所需的相关技能。</p>
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/CC%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B2%97%E4%BD%8D%E6%8A%80%E8%83%BD.png"/></div></div>
<p>开发工程师需要具备两种技能：<strong>硬技能</strong>和<strong>软技能</strong>。</p>
<p>硬技能包括各种计算机基础知识及必备的开发能力，可以通过技术年限不断获得。硬技能决定了能否成为一名合格的开发工程师。</p>
<p>软技能包括跨部门沟通能力，独立组织项目能力，此技能难以通过年限获得大量提升，它决定了工程师的上限。</p>
<p>加油，祝你好运!</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>const char*、const char[]与string</title>
    <url>/2023/09/28/C-%E4%B8%AD%E7%9A%84const-char-%E3%80%81const-char-%E4%B8%8Estring/</url>
    <content><![CDATA[<p>以下代码是基于gcc的vscode编译器编写的。首先导入运行示例的必要库，并指定标准命名空间std。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
<h2 id="1-const char* 与 const char[ ]">1. const char* 与 const char[ ]</h2>
<p>定义一个char型的指针p，指向字符串“now”；定义一个字符串数组p1，值为“now”。两者都属于<code>const</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p = <span class="string">&quot;now&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> p1[<span class="number">4</span>] = <span class="string">&quot;now&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>const char *  和 const char[ ] 都可以用于处理 C 风格的字符串。</p>
<p>const char* 主要出现在早期旧版本的代码中。这个指针本身是可变的（即可以改变它所指向的位置），但通过这个指针不能修改所指向数组的内容。它比较灵活（可以重新指向其他位置），在某些情况下更为方便； const char[ ]更接近于 “准确” 的类型，因为它更明确地表示这是一个字符数组。但它没有const char* 灵活。</p>
</blockquote>
<p>数组有一个特性，在很多用到数组名字的地方，编译器都会自动地将其转换成一个指向该数组首元素的指针。所以const char p1[4] = “now” 中p1也是一个指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; p &lt;&lt; endl;        <span class="comment">// p: now</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1: &quot;</span> &lt;&lt; p1 &lt;&lt; endl;      <span class="comment">// p1: now</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p: &quot;</span> &lt;&lt; *p &lt;&lt; endl;      <span class="comment">// *p: n</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p1: &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;    <span class="comment">// *p1: n</span></span><br></pre></td></tr></table></figure>
<p>但是，当我们打印指针p和p1时并没有输出地址值，输出的反而是它们指向的字符串数组。</p>
<p>这是因为cout有一个特殊的<strong>重载</strong>，当它看到一个 <code>const char[ ]</code> 或 <code>const char *</code> 类型，它会假定这是一个以空字符（即 ‘\0’）结尾的 C 风格字符串，并逐字符输出，直到遇到空字符为止。</p>
<p>后面两行就容易理解了，p 和 p1都是指向字符串数组首元素的指针，解引用后代表首元素。</p>
<h2 id="2其他类型数组-与 string">2.其他类型数组 与 string</h2>
<span id="more"></span>
<p>定义一个string对象s，它的内容是字符串字面值 “now”。</p>
<p>为了说明其余类型的数组和const char类型的不同，我们这里定义一个int型数组，它有四个元素：0, 1, 2, 3。由上文，<code>int i[4] = &#123;0,1,2,3&#125;</code>中 i 也是一个指针，指向该数组的首元素0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;now&quot;</span>;</span><br><span class="line"><span class="type">int</span> i[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; endl;        <span class="comment">// s: now</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; endl;        <span class="comment">// i: 0x61fdd0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*i: &quot;</span> &lt;&lt; *i &lt;&lt; endl;      <span class="comment">// *i: 0</span></span><br></pre></td></tr></table></figure>
<p>s为string的一个对象，与<code>int i[4]</code>中指针 i 代表含义不同，直接打印其值为初始化的&quot;now&quot;。</p>
<p>我们打印指针 i 时输出即为首元素0的地址，第一部分中特殊的重载并不适用。当解引用 i 时打印0。</p>
<p>string对象可以使用下标运算符<code>([ ])</code>访问string对象中的单个字符，这是string类所定义的。</p>
<p>与string类似，对于数组而言，只要指针指向的是数组里的元素，就可以执行下标运算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;s[0]: &quot;</span> &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;     <span class="comment">// s[0]: n</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[1]: &quot;</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; endl;     <span class="comment">// p[1]: o</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i[2]: &quot;</span> &lt;&lt; i[<span class="number">2</span>] &lt;&lt; endl;     <span class="comment">// i[2]: w</span></span><br></pre></td></tr></table></figure>
<p>我们可以分别用<code>s[0]</code>、<code>p[1]</code>、<code>i[2]</code>得到 s 中第0个字符，p 中第1个字符，i 中第2个字符（计数从0算起）。</p>
<p>对于数组而言，<code>p[1]</code>等价于<code>*(p + 1)</code>，<code>i[2]</code>等价于 <code>*(i + 2)</code>，其中p、i都是指向首元素的指针。</p>
<p>由于p所指向的数组是const的，所以直接对其某一个元素重新赋值会报错。而这对于非const的string类而言并没有限制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; endl;          </span><br><span class="line"><span class="comment">// p[1] = &#x27;a&#x27;;             // error: assignment of read-only location &#x27;*(p + 1)&#x27;/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU眼里的汇编语言</title>
    <url>/2023/10/30/CPU%E7%9C%BC%E9%87%8C%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>打开 Compiler Explorer， 写一个简单的自加函数：</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/image-20231030210847368.png" alt="image-20231030210847368" style="zoom:150%;" />
<h2 id="代码分析">代码分析</h2>
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/%25E6%25B1%2587%25E7%25BC%2596%25E8%25AF%25AD%25E8%25A8%2580-%25E7%25AC%25AC%25201%2520%25E9%25A1%25B5.drawio.png"/></div></div>
<p>该函数涉及到三个CPU寄存器：<strong>eax/rax</strong>、<strong>rbp</strong> 、<strong>rsp</strong>：</p>
<p><strong>eax/rax</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：一般用来存放数值，类似于C/C++里面的普通变量；</p>
<p><strong>rbp</strong> 、<strong>rsp</strong>：一般用来存放内存地址，类似于C/C++里面的指针变量。用来管理、读写内存的栈区（stack）。</p>
<p>初始状态寄存器的值均为 0x100。</p>
<p>首先看函数对应的汇编指令：push。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/image-20231030204311218.png" alt="image-20231030204311218" style="zoom:150%;" />
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/2.png"/></div></div>
<p>push对应了两个微操作：</p>
<ol>
<li>将寄存器 rbp 的值，存放在“栈顶”寄存器 rsp 指向的内存下方（rsp 所指内存的Value值为 rbp 的地址）。</li>
<li>随着“栈顶”向低生长，也就是让 rsp 寄存器的值减 4。</li>
</ol>
<p>随后是简单的 mov 指令，把寄存器 rsp 的值赋给 rbp，如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/image-20231030204515184.png" alt="image-20231030204515184" style="zoom:150%;" />
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/3.png"/></div></div>
<p>接着是一个较为复杂的 mov 指令<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。但通过参考源代码，我们很容易猜出它是要把数值 1，写入到变量 a 所在的内存。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/image-20231030204607840.png" alt="image-20231030204607840" style="zoom:150%;" />
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/4.png"/></div></div>
<p>mov 指令和数值 1 都很容易找到，但变量 a 的内存地址就颇为复杂。不过关键字 PTR 提示我们：这是一个指针操作，这也恰好对应了 rbp 本身就是类似于指针变量的寄存器。</p>
<p>所以，这行汇编代码对应C/C++代码类似于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*(rbp - <span class="number">4</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>变量 a 的内存地址等于寄存器 rbp 的值减4；而中括号<code>[ ]</code>就相当于指针变量的解引用<code>*</code>操作；DWORD是指针类型，表明数值 1 将占用 4 个字节的长度。</p>
<blockquote>
<p>这里说个题外话：对比 C/C++ 和汇编语言可以看出，C/C++语言是最接近底层的高级语言。</p>
</blockquote>
<p>接着进行自加运算。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/image-20231030200848432.png" alt="image-20231030200848432" style="zoom:150%;" />
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/5.png"/></div></div>
<p>带 PTR 和 [ ] 的 add 指令也有两个微操作：</p>
<ol>
<li>首先，用指针的<code>*</code>操作获得变量 a 的值，并与 2 做加法运算；</li>
<li>把加法运算得到的结果，通过指针的<code>*</code>写入到变量 a 所在的内存。</li>
</ol>
<p>随后的 mov 指令与上文的相似，即将变量 a 的值从内存中读出来，写入到寄存器 eax 里面。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/image-20231030201610873.png" alt="image-20231030201610873" style="zoom:150%;" />
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/6.png"/></div></div>
<p>这里对应的C/C++ 语言类似于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">eax = *(rbp - <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即使是普通变量操作，背后的实现原理也跟“指针”脱不了干系。因为在 CPU 眼里，万物皆有地址，万物皆可指针。</p>
</blockquote>
<p>最后，就是 push 的反向操作 pop。</p>
<p>它也对应了两个微操作：</p>
<ol>
<li>把寄存器 rsp 指向的“栈顶”内存的值 0x100，写入到寄存器 rbp。</li>
<li>随着“栈顶”的升高， rsp 寄存器的值也随之加 4。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/image-20231030202453405.png" alt="image-20231030202453405" style="zoom:150%;" />
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/test.png"/></div></div>
<h2 id="总结">总结</h2>
<p>再宏伟、壮观的房子，真正施工的时候，不过是在重复搭钢筋、倒水泥；再搭钢筋、再倒水泥的过程。CPU 也是如此，我们不过是把数据，在寄存器和内存之间搬来搬去。</p>
<p>通过上文的代码分析我们发现，为了做 1 次简单的 +2 运算，居然产生了（至少）5 次内存读写，内存读写占比高达 83%。据有些机构统计指出，CPU 的内存读写，占据了 CPU 90%的工作负荷。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>寄存器 eax 和寄存器 rax 的区别：寄存器 eax 是 32 位的 x86 CPU的寄存器，如今的 x86 CPU多是 64 位的，其对应的寄存器是 rax，eax 只是 rax 的低 32 位而已。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>汇编语言中，mov 指令用于写入。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>以独立语句初始化shared_ptr</title>
    <url>/2023/11/21/%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%88%9D%E5%A7%8B%E5%8C%96shared-ptr/</url>
    <content><![CDATA[<p>在<a href="https://www.xuluo.online/2023/10/28/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88shared-ptr%E7%9A%84%E5%BA%94%E7%94%A8/">智能指针shared_ptr的应用</a>中，我们提到了可以利用智能指针 shared_ptr 以避免资源泄漏。尽管如此，在 C++中，某些情况下使用 shared_ptr 依然会泄漏资源，这可能与我们的初衷相违背。考虑下面的一种情况：</p>
<p>假设我们有个函数用来表示程序优先执行的等级，另一个函数用来在某动态分配所得的 Widget 上进行某些带有优先权的处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>现考虑调用 processWidget :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
<p>但直接调用上面代码无法通过编译，这是因为上述代码暗含了从<code>new Widget</code>到<code>shared_ptr</code>的隐式转换，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;Widget&gt; pw = <span class="keyword">new</span> Widget;</span><br></pre></td></tr></table></figure>
<p>shared_ptr 的构造函数可以需要一个原始指针，但该构造函数是一个 <strong>explicit</strong> 的构造函数，不能进行隐式转换，可见下图 shared_ptr 的源代码：</p>
<div class="tag-plugin image"><div class="image-bg"><img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/image-20231202203738381.png"/></div></div>
<p>因此可以为了通过编译，可以写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
<p>这样似乎很完美，我们利用了 shared_ptr 来管理资源，但不幸的是，上述调用仍可能泄漏资源。</p>
<p>processWidget 函数的第二实参只是一个单纯的对 priority 函数的调用，但是第一实参 std::shared_ptr&lt;Widget&gt;(new Widget) 由两部分组成：</p>
<ul>
<li>执行 “new Widget” 表达式</li>
<li>调用 shared_ptr 构造函数</li>
</ul>
<p>于是在调用 precessWidget 之前，编译器必须做一下三件事：</p>
<ul>
<li>调用 priority</li>
<li>执行 “new Widget”</li>
<li>调用 shared_ptr 构造函数</li>
</ul>
<p>C++编译器以什么样的次序完成这些事情呢？<strong>弹性很大</strong>。这与Java、C# 不同，这两种语言总是以固定次序完成函数参数的初始化。可以确定的是，<code>new Widget</code>一定执行于  <code>shared_ptr</code> 构造函数之前，但对 priority 的调用可以排在第一或第二或第三执行。如果编译器选择以第二顺位执行它，最终获得这样的操作序列：</p>
<ol>
<li>执行 “new Widget”</li>
<li>调用 priority</li>
<li>调用 shared_ptr 构造函数</li>
</ol>
<p>考虑这样一种情况，如果 <strong>priority 的调用导致异常</strong>，会发生什么？在此情况下，“new Widget”返回的指针将会遗失，因为它尚未被放入 shared_ptr 内，后者是我们期待用来避免资源泄漏的武器。是的，在对 processWidget 的调用过程中可能引发了资源泄漏，因为在资源被创建（“new Widget”）和资源被转换为资源管理对象（shared_ptr 初始化）的两个时间点之间，<strong>可能发生异常干扰</strong>。</p>
<p>避免发生这类问题很简单：<em>使用分离语句</em>，分别写出 （1）创建Widget，将它置入一个智能指针内，（2）将这个智能指针传给 processWidget：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;		<span class="comment">// 在单独语句内以指针指针存储 newed 所得对象</span></span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());				<span class="comment">// 这样调用绝不会导致资源泄漏</span></span><br></pre></td></tr></table></figure>
<p>编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在一个语句内它才有自由度）。在上述修订后的代码内，“new Widget”表达式以及“对shared_ptr构造函数的调用“这两个动作，和”对priority的调用“是分隔开的，位于不同语句内，所以编译器不能在它们之间选择任意执行的次序。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽可能使用const</title>
    <url>/2023/10/17/const/</url>
    <content><![CDATA[<h2 id="const-for pointer">const for pointer</h2>
<p>const 约束指针分为两种：常量指针（<strong>const pointer</strong>）<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>和指向常量的指针（<strong>pointer to const</strong>）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = greeting;                <span class="comment">//non-const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = greeting;          <span class="comment">//non-const pointer, const data</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;          <span class="comment">//const pointer, non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;    <span class="comment">//const pointer, const data</span></span><br></pre></td></tr></table></figure>
<p>对于<strong>pointer to const</strong>，关键字<code>const</code>可以放在类型之前，也可以放在类型之后、星号<code>*</code>之前。即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i; </span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> *p = &amp;i;</span><br></pre></td></tr></table></figure>
<h2 id="const-for stl iterator">const for STL iterator</h2>
<p>STL迭代器的作用就像 <code>T*</code>指针。对应常量指针（const pointer）和指向常量的指针（pointer to const），STL迭代器也有不同的声明方式：</p>
<ol>
<li>
<p>类似于<code>T* const</code>指针。在最前面声明<code>const</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();  <span class="comment">// iter类似于 T* const </span></span><br><span class="line">*iter = <span class="number">9</span>;                                       <span class="comment">// 正确，可以改变iter所指内容的值</span></span><br><span class="line">iter++;                                          <span class="comment">// 错误！iter本身是const的</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类似于<code>const T*</code>指针。需要用<strong>const_iterator</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator iter1 = vec.<span class="built_in">begin</span>(); <span class="comment">// iter1类似于 const T*</span></span><br><span class="line">*iter1 = <span class="number">99</span>;                                     <span class="comment">// 错误！*iter1是const</span></span><br><span class="line">iter1++;                                         <span class="comment">// 正确，可以改变iter1自身的值</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="const-for function return value">const for function return value</h2>
<p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，又不至于放弃安全性和高效性。考虑下面一个例子，定义有理数<code>Rational</code>类的<code>operator*</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>
<p>这里返回一个<code>const</code>对象是为了避免出现错误造成的意外情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (a * b = c) ...                                   <span class="comment">// 其实是想做一个比较动作</span></span><br></pre></td></tr></table></figure>
<p>如果a和b都是内置类型，这样的代码直截了当就是不合法。将<code>operator*</code>的返回值声明为<code>const</code>可以防止出现上面的错误。这样做与内置类型恰好兼容。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>顶层const <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>底层const <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针shared_ptr的应用</title>
    <url>/2023/10/28/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88shared-ptr%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>与Java不同的是，C++程序员需要手动管理众多资源，典型的就是<strong>内存回收</strong>。通过使用智能指针 <code>shared_ptr </code>可以几乎消除内存泄漏的资源管理问题。这里我们分别以内存中的堆区和栈区为例，介绍 <code>shared_ptr </code>在资源管理方面的优势。</p>
<h2 id="堆区（heap-based)">堆区（heap-based)</h2>
<p>假设有一个投资 class 的基类<code>Investment</code>，其余各种各样的投资类型继承它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123;...&#125;                        <span class="comment">// “投资类型”继承体系中的基类</span></span><br></pre></td></tr></table></figure>
<p>现有一个工厂（factory）函数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>供应我们某一个特定的 Investment 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;              <span class="comment">// 返回指针，指向Investment继承体系内的动态分配对象</span></span><br></pre></td></tr></table></figure>
<p>为了避免泄露内存和其他资源，将 factory 函数返回的每一个对象适当地 delete 掉很重要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Investment* pInv = <span class="built_in">createInvestment</span>();      <span class="comment">// 调用 factory 函数 </span></span><br><span class="line"></span><br><span class="line">...                                         <span class="comment">// 使用它</span></span><br><span class="line"><span class="keyword">delete</span> pInv;                                <span class="comment">// 释放它，避免内存泄漏</span></span><br></pre></td></tr></table></figure>
<p>现考虑有个 f 函数履行了这个责任：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Investment* pInv = <span class="built_in">createInvestment</span>();      <span class="comment">// 调用 factory 函数 </span></span><br><span class="line"></span><br><span class="line">	...                                         </span><br><span class="line">	<span class="keyword">delete</span> pInv;                                <span class="comment">// 释放pInv所指的对象，避免内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前看起来似乎没什么问题，但在某些情况下，f 可能无法履行删除 pInv 所指的对象的责任。如：</p>
<ul>
<li>“ … ”区域内有一个过早的 return 语句，导致控制流不会触及到 delete 语句</li>
<li>“ … ”区域内的语句抛出异常</li>
</ul>
<p>上面代码可能在初期版本没什么问题，但是随着时间渐渐过去可能会被修改、维护，如果有些人添加 return 语句或者 f 的区域有可能调用一个“过去从未抛出异常，却在被 ‘改善后’ 开始出现异常“时，那么这就背离了函数的资源管理策略的初衷。</p>
<p>为了确保 createInvestment 返回资源总是被释放，我们需要确保当控制流离开 f，该对象的析构函数会自动释放这些资源。这就引出了智能指针—<strong>shared_ptr</strong>。下面示范如何用 shared_ptr 以避免 f 函数潜在的资源泄漏的可能性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;     <span class="comment">// 调用 factory 函数</span></span><br><span class="line">    </span><br><span class="line">    ...                                                       <span class="comment">// 一如既往使用 pInv</span></span><br><span class="line">&#125;                                                             <span class="comment">// 经由 shared_ptr 析构函数自动删除 pInv</span></span><br></pre></td></tr></table></figure>
<p>当 shared_ptr 被销毁（例如一个局部的 shared_ptr 离开其作用域）时，计数器该 shared_ptr 关联的计数器会递减。一旦计数器变为0，它就会自动释放自己所管理的对象。</p>
<p>在改进后的代码中，不论控制流如何离开区块，如过早 return 或抛出异常，一旦对象 pInv 被销毁（离开 f 作用域），其析构函数会被自动调用，于是资源被释放。<em>(在某些情况下，即使使用 shared_ptr 仍可能出现资源泄漏的情况，详见<a href="https://www.xuluo.online/2023/11/21/%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%88%9D%E5%A7%8B%E5%8C%96shared-ptr/">以独立语句初始化shared_ptr</a>)</em></p>
<p>需要补充的是，shared_pte 在其析构函数内做 delete 而不是 delete[ ]动作，这就意味着在动态分配而得到的数组身上使用shared_ptr是个糟糕的行为，尽管它能通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std:: <span class="function">shared_pte&lt;std::string&gt; <span class="title">sps</span><span class="params">(<span class="keyword">new</span> std::string[<span class="number">10</span>])</span></span>;      <span class="comment">// 很糟糕！会用上错误的 delete 形式</span></span><br><span class="line">std:: <span class="function">shared_pte&lt;<span class="type">int</span>&gt; <span class="title">spi</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">1024</span>])</span></span>;                    <span class="comment">// 同样问题</span></span><br></pre></td></tr></table></figure>
<p>不必惊讶为什么C++工程师没有解决这个问题，即没有特别针对”C++动态分配数组“而设计的类型shared_ptr这样的东西，这是因为STL容器里的 vector 和 string 几乎可以取代动态数组，它们两个有自己的析构函数，可以避免这个问题。</p>
<h2 id="栈区（stack-based）##">栈区（stack-based）##</h2>
<p>我们可以使用 shared_ptr 来建立自己的资源管理类。</p>
<p>假设我们有一个 class Lock 以及它的两个成员函数 lock、unlock：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;                                        <span class="comment">// 锁定pm所指的互斥器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;                                      <span class="comment">// 将互斥器解除锁定</span></span><br></pre></td></tr></table></figure>
<p>为确保不会忘记将一个被锁住的Mutex解锁，可以通过建立一个 class  Lock 来管理机锁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function">explict <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : mutexPtr(pm)&#123;</span></span><br><span class="line">            <span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">        &#125;                                                    <span class="comment">// 获得资源</span></span><br><span class="line">    ~<span class="built_in">Lock</span>() &#123; <span class="built_in">unlock</span>(mutexPtr); &#125;                            <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">private</span>：</span><br><span class="line">        Mutex *mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户对 Lock 的用法类似于 shared_ptr 的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mutex m;                                                     <span class="comment">// 定义你需要的互斥器</span></span><br><span class="line">...</span><br><span class="line">&#123;                                                            <span class="comment">// 建立一个区块用来定义 critical section</span></span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;                                             <span class="comment">// 锁定互斥器</span></span><br><span class="line">    ...                                                      <span class="comment">// 执行 critical section 内的操作</span></span><br><span class="line">&#125;                                                            <span class="comment">// 执行析构函数</span></span><br></pre></td></tr></table></figure>
<p>目前看起来没什么问题，但是如果 Lock 对象被复制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;                                                <span class="comment">// 锁定m</span></span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(ml1)</span></span>;                                               <span class="comment">// 复制ml1到ml2上，会出现问题</span></span><br></pre></td></tr></table></figure>
<p>当我们将 ml1 复制到 ml2 上时，我们希望保留 ml2的资源 <code>mutexPtr</code>，但如果 ml1 离开区块，其析构函数执行，那么经过复制后的 ml2 里的资源也会被释放，这可能与我们的初衷不符。我们希望保留资源，直到它的最后一个使用者（某对象）被销毁，而中间其余对象被销毁不受影响。为此，我们可以引入 shared_ptr。</p>
<p>如果简单地将 Mutex*  改为 shared_ptr&lt;Mutex&gt;，那么其析构函数行为是”当引用计数为0时删除所指之物“，而不是执行函数 unlock 。幸运的是，shared_ptr 允许指定所谓的”删除器“，即一个函数或函数对象，当引用计数为0时被调用。下面是更新后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function">explict <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : mutexPtr(pm， unlock)&#123;</span>     <span class="comment">// 以某个 Mutex 初始化 shared_ptr 并以 unlock 函数作为删除器</span></span><br><span class="line">            <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">        &#125;                                                    <span class="comment">// 获得资源</span></span><br><span class="line">    <span class="keyword">private</span>：</span><br><span class="line">        std::shared_ptr&lt;Mutex&gt; mutexPtr;                     <span class="comment">// 使用 shared_ptr 代替 raw pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，本例中的 Lock class 不再声明析构函数，因为没有必要。<strong>class</strong>的析构函数（无论是编译器生成的还是用户自定的）会自动调用其 <strong>non-static</strong>成员变量（本例为 mutexPtr）的析构函数。而 mutexPtr 的析构函数会在互斥器引用计数为0时自动调用 shared_ptr 的删除器（本例为 unlock）。</p>
<h2 id="内存主要分区">内存主要分区</h2>
<p>最后简要介绍下内存主要的分区。</p>
<ol>
<li>堆区（heap）：用来储存<strong>动态分配</strong>的对象，即由 malloc/new 分配的内存块。这是在程序运行时分配的对象，当其不再使用时，我们的代码必须显示地销毁它们。</li>
<li>栈区（stack）：用来保存定义在函数内的非 static 对象。</li>
<li>静态内存：用来保存局部 static 对象<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>、类 static 数据成员以及定义在任何函数之外的变量（全局变量）。</li>
</ol>
<p>分配在栈区或者静态内存中的对象由编译器自动创建和销毁。</p>
<img src="https://cdn.jsdelivr.net/gh/zermatt-luo/MyBlog@main/img/static_1.png" alt="static_1" style="zoom:80%;" />
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>factory（工厂）函数屏蔽了实现细节，返回一个<strong>base class</strong>指针，指向新生成的<strong>derived class</strong>对象。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>函数内的 static 对象是局部  static 对象（local static 对象，因为它们对函数而言是 local 的），其他 static 对象称为全局  static 对象。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>用十年时间自学编程</title>
    <url>/2023/09/28/%E7%94%A8%E5%8D%81%E5%B9%B4%E6%97%B6%E9%97%B4%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在网上找到了一篇关于编程心得交流分享的文章《Teach Yourself Programming in Ten Years》，<a href="http://norvig.com/21-days.html#answers">原文链接</a>放到这里。下面是中文翻译版：</p>
<center style="font-size: 27px; font-weight: bold;">
  Teach Yourself Programming in Ten Years
</center>
<center style="font-size: 20px; font-weight: bold;">
  Peter Norvig
</center>
<h4 id="为什么每个人都这么急切？">为什么每个人都这么急切？</h4>
<p>走进任何一家书店，你都会看到《24小时自学Java》这样的书，以及无数教你几天或几小时内学会C、SQL、Ruby、算法等等。在亚马逊高级搜索中，搜索[title: teach, yourself, hours, since: 2000]，找到了512本这样的书。在前十名中，九本是编程书籍，另一本是关于记账的。用“learn”替换“teach yourself”或用“days”替换“hours”得到的结果也相似。</p>
<p>这说明两种情况，要么大家都急着学编程，要么编程真的比其他技能容易得多。Felleisen等人在他们的书《如何设计程序》中也提到了这种现象，说：“写糟糕的代码很简单，21天就能学会，哪怕你是个门外汉。”还有一部Abtruse Goose的漫画也做了类似的描述。<br>
那么，《24小时自学C++》这样的标题到底意味着什么呢？</p>
<ul>
<li>自学：在24小时里，你根本没办法写出几个有深度的程序，更别说从中吸取经验教训了。你也没机会与资深程序员合作，体验真正的C++编程是怎样的。简单说，你学不到多少。这本书只能教你一些皮毛，而不是真正的深入理解。就像亚历山大·教皇说的，浅尝辄止是很危险的（<strong>a little learning is a dangerous thing</strong>）。</li>
<li>C++：你可能在24小时内学会一些C++的基础语法（如果你之前已经学过其他编程语言的话），但你真的了解C++吗？如果你只是一个初学者，你可能只能用C++的语法写出初级的程序，但你真的理解C++的精髓吗？Alan Perlis曾说：“一个不改变你编程思维的语言，是没必要学的（<strong>A language that doesn’t affect the way you think about programming, is not worth knowing</strong>）。”或许，你只是为了完成某个特定任务，需要学一点C++（或者是JavaScript或Processing）。但那样，你其实并没有真正学会编程，只是学会了如何完成那个任务。</li>
<li>24小时：显然，这时间远远不够，下一部分会进一步说明。</li>
</ul>
<span id="more"></span>
<h4 id="十年自学编程">十年自学编程</h4>
<p>研究者（如Bloom (1985)、Bryan &amp; Harter (1899)、Hayes (1989)、Simmon &amp; Chase (1973)）已经证明，在许多领域，如下棋、音乐创作、电报操作、绘画、钢琴演奏、游泳、网球，以及神经心理学和拓扑学的研究中，要达到专家水平大约需要十年时间。关键是有目的的实践：不仅仅是重复做，而是给自己设定一个略超出当前能力的任务，尝试去做，做的时候和做完后分析自己的表现，并纠正错误。然后再重复。再重复。似乎没有真正的捷径：即使是4岁就展现出音乐天赋的莫扎特，也花了13年时间才开始创作世界级的音乐。披头士乐队似乎在1964年凭借一系列的热门歌曲和在Ed Sullivan秀上的表现一炮而红。但他们从1957年开始就在利物浦和汉堡的小俱乐部演出，尽管他们很早就受到大众的喜爱，但他们的第一个广受好评的作品，Sgt. Peppers，是在1967年发布的。  Malcolm Gladwell 推广了这个观点，尽管他更注重的是10,000小时，而不是10年。Henri Cartier-Bresson (1908-2004)有另一个标准：“你的前10,000张照片是最差的。”（他没想到在数字相机的时代，有些人一周内就能达到这个数字。）真正的专业水平可能需要一生的时间：Samuel Johnson (1709-1784)说：“任何领域的卓越都只能通过一生的努力来获得；它的价值不菲。”乔叟(1340-1400)抱怨说：“生命短暂，技艺学习之路漫长。”希波克拉底（公元前400年左右）因“ars longa, vita brevis”而著称，这是更长的引文“Ars longa, vita brevis”而著称，这是更长的引文“Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”的一部分，英文意为“生命短暂，技艺长久，机会稍纵即逝，实验充满风险，判断困难。”当然，没有一个固定的数字可以作为最终答案：认为所有技能（如编程、下棋、打跳棋和演奏音乐）都需要完全相同的时间来掌握，或者所有人都需要完全相同的时间，似乎都不合理。正如K. Anders Ericsson教授所说：“在大多数领域，即使是最有天赋的人也需要相当长的时间才能达到最高水平。10,000小时这个数字只是给你一个感觉，我们说的是每周10到20小时，连一些人认为最有天赋的人也需要这么长时间才能达到最高水平。”</p>
<h4 id="你想成为一名程序员吗？">你想成为一名程序员吗？</h4>
<p>以下是我为成功编程提供的建议：<br>
对编程产生兴趣，并因为它有趣而去做。确保它始终足够有趣，这样你会愿意投入你的十年或10,000小时。<br>
以下是我为成功编程提供的建议：</p>
<ol>
<li>对编程产生兴趣，并因为它有趣而去做。兴趣是任何长期承诺的重要驱动力，编程也不例外。如果你对编程感到兴趣，你会更愿意投入时间和努力去学习和提高。编程本身有很多有趣和挑战性的方面，从解决复杂问题，到实现创新的算法，再到构建引人入胜的应用程序。</li>
<li>动手编程。最好的学习方式是实践中学习。更专业地说，“个体在某一领域的最大性能水平并不是随着经验的增长而自动获得的，但即使是经验丰富的个体，也可以通过有意识地努力提高来提高性能水平。”以及“最有效的学习需要一个为特定个体设定的具有适当难度的明确定义任务、有益的反馈以及重复和纠正错误的机会。”《实践中的认知：日常生活中的心智、数学和文化》这本书是这种观点的一个有趣的参考。</li>
<li>与其他程序员交流；阅读其他人的程序。这比任何书籍或培训课程都更重要。</li>
<li>如果你愿意，可以在大学度过四年（或在研究生院度过更长时间）。这将使你有机会获得一些需要资格证书的工作，并使你对这个领域有更深入的了解，但如果你不喜欢学校，你可以（只要有一些决心）自己或在工作中获得类似的经验。无论如何，仅仅通过书本学习是不够的。“计算机科学教育不能使任何人成为专家程序员，正如学习画笔和颜料不能使任何人成为专家画家一样。”《新黑客词典》的作者Eric Raymond如是说。我雇佣过的最好的程序员之一只有高中学历；他生产了很多优秀的软件，有自己的新闻组，并通过股票期权赚了足够的钱买下自己的夜总会。</li>
<li>与其他程序员一起参与项目。在某些项目中成为最好的程序员；在其他一些项目中成为最差的。当你是最好的时候，你可以测试你领导项目的能力，并用你的动力激励他人。当你是最差的时候，你会学到高手们都做些什么，以及他们不喜欢做什么（因为他们让你帮他们做那些事）。</li>
<li>至少学习六种编程语言。包括一种强调类抽象的语言（如Java或C++），一种强调函数抽象的语言（如Lisp或ML或Haskell），一种支持语法抽象的语言（如Lisp），一种支持声明式规范的语言（如Prolog或C++模板），以及一种强调并行性的语言（如Clojure或Go）。</li>
<li>记住，“计算机科学”中有“计算机”这个词。了解你的计算机执行一条指令、从内存中取出一个字（有或没有缓存未命中）、从磁盘连续读取字、以及在磁盘上寻找新位置所需的时间。（<a href="http://norvig.com/21-days.html#answers">答案在这里</a>）</li>
<li>参与一项语言标准化工作。可以是ANSI C++委员会，也可以是决定你们本地编码风格是否采用2个或4个空格缩进。无论如何，你都可以了解其他人对语言的喜好，他们对此有多深的感情，甚至可能了解他们为什么有这样的感情。</li>
<li>明智地尽快退出语言标准化工作。</li>
</ol>
<p>考虑到这些，仅仅通过书本学习能走多远还是一个疑问。在我第一个孩子出生之前，我读了所有的育儿书，但仍然感觉自己像个毫无经验的新手。30个月后，当我第二个孩子即将出生时，我是否回到书本上进行复习？没有。相反，我依赖于我的亲身经验，这比专家写的数千页书籍对我来说更有用、更令人放心。<br>
Fred Brooks在他的文章《No Silver Bullets》(没有银弹)中，为找到优秀的软件设计师提出了一个三部分的计划：</p>
<ul>
<li>尽早系统地识别顶级设计师。</li>
<li>指派一位职业导师负责潜在人才的发展，并仔细维护其职业档案。</li>
<li>为成长中的设计师提供互动和激励彼此的机会。</li>
</ul>
<p>这意味着有些人已经具备成为优秀设计师的必要品质；任务是适当地引导他们。Alan Perlis更简洁地说：“每个人都可以被教会雕塑：但米开朗基罗则需要被教如何不这样做。对于伟大的程序员也是如此。”Perlis的意思是，伟大的人有一种超越他们培训的内在品质。但这种品质从哪里来？是与生俱来的吗？还是他们通过勤奋发展出来的？正如《美食总动员》中的虚构厨师Auguste Gusteau所说：“人人都可以做饭，但只有无畏的人才能成为伟大的厨师。”我更认为这是愿意为刻意练习投入生活的大部分时间。但也许“无畏”是一种总结这种状态的方式。或者，正如Gusteau的评论家Anton Ego所说：“并不是每个人都可以成为伟大的艺术家，但伟大的艺术家可以来自任何地方。”  所以，放心去买那本Java/Ruby/Javascript/PHP的书；你可能会从中受益。但你的生活或你作为程序员的真正专业技能不会在24小时或21天内发生改变。如何努力在24个月内不断进步呢？好吧，现在你开始了。</p>
]]></content>
      <tags>
        <tag>编程建议</tag>
      </tags>
  </entry>
</search>
